/* File generated by the BNF Converter (bnfc 2.9.4). */

/*** Visitor Design Pattern Skeleton. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "Skeleton.H"


namespace Nameless
{
void Skeleton::visitProgram(Program *t) {} //abstract class
void Skeleton::visitExpr(Expr *t) {} //abstract class
void Skeleton::visitBindingExpr(BindingExpr *t) {} //abstract class
void Skeleton::visitType(Type *t) {} //abstract class
void Skeleton::visitFieldTypeExpr(FieldTypeExpr *t) {} //abstract class
void Skeleton::visitTyping(Typing *t) {} //abstract class

void Skeleton::visitProgramExprs(ProgramExprs *program_exprs)
{
  /* Code For ProgramExprs Goes Here */

  if (program_exprs->listexpr_) program_exprs->listexpr_->accept(this);

}

void Skeleton::visitIf(If *if_)
{
  /* Code For If Goes Here */

  if (if_->expr_1) if_->expr_1->accept(this);
  if (if_->expr_2) if_->expr_2->accept(this);
  if (if_->expr_3) if_->expr_3->accept(this);

}

void Skeleton::visitLet(Let *let)
{
  /* Code For Let Goes Here */

  if (let->expr_1) let->expr_1->accept(this);
  if (let->expr_2) let->expr_2->accept(this);

}

void Skeleton::visitAbstraction(Abstraction *abstraction)
{
  /* Code For Abstraction Goes Here */

  if (abstraction->type_) abstraction->type_->accept(this);
  if (abstraction->expr_) abstraction->expr_->accept(this);

}

void Skeleton::visitRecord(Record *record)
{
  /* Code For Record Goes Here */

  if (record->listbindingexpr_) record->listbindingexpr_->accept(this);

}

void Skeleton::visitApplication(Application *application)
{
  /* Code For Application Goes Here */

  if (application->expr_1) application->expr_1->accept(this);
  if (application->expr_2) application->expr_2->accept(this);

}

void Skeleton::visitSucc(Succ *succ)
{
  /* Code For Succ Goes Here */

  if (succ->expr_) succ->expr_->accept(this);

}

void Skeleton::visitDot(Dot *dot)
{
  /* Code For Dot Goes Here */

  if (dot->expr_) dot->expr_->accept(this);
  visitIdent(dot->ident_);

}

void Skeleton::visitPred(Pred *pred)
{
  /* Code For Pred Goes Here */

  if (pred->expr_) pred->expr_->accept(this);

}

void Skeleton::visitIsZero(IsZero *is_zero)
{
  /* Code For IsZero Goes Here */

  if (is_zero->expr_) is_zero->expr_->accept(this);

}

void Skeleton::visitConstTrue(ConstTrue *const_true)
{
  /* Code For ConstTrue Goes Here */


}

void Skeleton::visitConstFalse(ConstFalse *const_false)
{
  /* Code For ConstFalse Goes Here */


}

void Skeleton::visitConstZero(ConstZero *const_zero)
{
  /* Code For ConstZero Goes Here */


}

void Skeleton::visitFreeVar(FreeVar *free_var)
{
  /* Code For FreeVar Goes Here */

  visitIdent(free_var->ident_);

}

void Skeleton::visitBoundVar(BoundVar *bound_var)
{
  /* Code For BoundVar Goes Here */

  visitInteger(bound_var->integer_);

}

void Skeleton::visitBinding(Binding *binding)
{
  /* Code For Binding Goes Here */

  visitIdent(binding->ident_);
  if (binding->expr_) binding->expr_->accept(this);

}

void Skeleton::visitFunType(FunType *fun_type)
{
  /* Code For FunType Goes Here */

  if (fun_type->type_1) fun_type->type_1->accept(this);
  if (fun_type->type_2) fun_type->type_2->accept(this);

}

void Skeleton::visitRecordType(RecordType *record_type)
{
  /* Code For RecordType Goes Here */

  if (record_type->listfieldtypeexpr_) record_type->listfieldtypeexpr_->accept(this);

}

void Skeleton::visitBoolType(BoolType *bool_type)
{
  /* Code For BoolType Goes Here */


}

void Skeleton::visitNatType(NatType *nat_type)
{
  /* Code For NatType Goes Here */


}

void Skeleton::visitFieldType(FieldType *field_type)
{
  /* Code For FieldType Goes Here */

  visitIdent(field_type->ident_);
  if (field_type->type_) field_type->type_->accept(this);

}

void Skeleton::visitTypingStmt(TypingStmt *typing_stmt)
{
  /* Code For TypingStmt Goes Here */

  if (typing_stmt->expr_) typing_stmt->expr_->accept(this);
  if (typing_stmt->type_) typing_stmt->type_->accept(this);

}


void Skeleton::visitListExpr(ListExpr *list_expr)
{
  for (ListExpr::iterator i = list_expr->begin() ; i != list_expr->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void Skeleton::visitListBindingExpr(ListBindingExpr *list_binding_expr)
{
  for (ListBindingExpr::iterator i = list_binding_expr->begin() ; i != list_binding_expr->end() ; ++i)
  {
    (*i)->accept(this);
  }
}

void Skeleton::visitListFieldTypeExpr(ListFieldTypeExpr *list_field_type_expr)
{
  for (ListFieldTypeExpr::iterator i = list_field_type_expr->begin() ; i != list_field_type_expr->end() ; ++i)
  {
    (*i)->accept(this);
  }
}


void Skeleton::visitInteger(Integer x)
{
  /* Code for Integer Goes Here */
}

void Skeleton::visitChar(Char x)
{
  /* Code for Char Goes Here */
}

void Skeleton::visitDouble(Double x)
{
  /* Code for Double Goes Here */
}

void Skeleton::visitString(String x)
{
  /* Code for String Goes Here */
}

void Skeleton::visitIdent(Ident x)
{
  /* Code for Ident Goes Here */
}


}
