/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef NAMELESS_ABSYN_HEADER
#define NAMELESS_ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.
namespace Nameless
{
/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class Expr;
class BindingExpr;
class Type;
class FieldTypeExpr;
class Typing;
class ProgramExprs;
class If;
class Let;
class Abstraction;
class Record;
class Binding;
class Application;
class Succ;
class Dot;
class Pred;
class IsZero;
class ConstTrue;
class ConstFalse;
class ConstZero;
class FreeVar;
class BoundVar;
class FunType;
class RecordType;
class BoolType;
class NatType;
class FieldType;
class TypingStmt;
class ListExpr;
class ListBindingExpr;
class ListFieldTypeExpr;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitBindingExpr(BindingExpr *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitFieldTypeExpr(FieldTypeExpr *p) = 0;
  virtual void visitTyping(Typing *p) = 0;
  virtual void visitProgramExprs(ProgramExprs *p) = 0;
  virtual void visitIf(If *p) = 0;
  virtual void visitLet(Let *p) = 0;
  virtual void visitAbstraction(Abstraction *p) = 0;
  virtual void visitRecord(Record *p) = 0;
  virtual void visitBinding(Binding *p) = 0;
  virtual void visitApplication(Application *p) = 0;
  virtual void visitSucc(Succ *p) = 0;
  virtual void visitDot(Dot *p) = 0;
  virtual void visitPred(Pred *p) = 0;
  virtual void visitIsZero(IsZero *p) = 0;
  virtual void visitConstTrue(ConstTrue *p) = 0;
  virtual void visitConstFalse(ConstFalse *p) = 0;
  virtual void visitConstZero(ConstZero *p) = 0;
  virtual void visitFreeVar(FreeVar *p) = 0;
  virtual void visitBoundVar(BoundVar *p) = 0;
  virtual void visitFunType(FunType *p) = 0;
  virtual void visitRecordType(RecordType *p) = 0;
  virtual void visitBoolType(BoolType *p) = 0;
  virtual void visitNatType(NatType *p) = 0;
  virtual void visitFieldType(FieldType *p) = 0;
  virtual void visitTypingStmt(TypingStmt *p) = 0;
  virtual void visitListExpr(ListExpr *p) = 0;
  virtual void visitListBindingExpr(ListBindingExpr *p) = 0;
  virtual void visitListFieldTypeExpr(ListFieldTypeExpr *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;
  int line_number, char_number;
};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;
  int line_number, char_number;
};

class BindingExpr : public Visitable
{
public:
  virtual BindingExpr *clone() const = 0;
  int line_number, char_number;
};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;
  int line_number, char_number;
};

class FieldTypeExpr : public Visitable
{
public:
  virtual FieldTypeExpr *clone() const = 0;
  int line_number, char_number;
};

class Typing : public Visitable
{
public:
  virtual Typing *clone() const = 0;
  int line_number, char_number;
};



class ProgramExprs : public Program
{
public:
  ListExpr *listexpr_;

  ProgramExprs(const ProgramExprs &);
  ProgramExprs &operator=(const ProgramExprs &);
  ProgramExprs(ListExpr *p1);
  ~ProgramExprs();
  virtual void accept(Visitor *v);
  virtual ProgramExprs *clone() const;
  void swap(ProgramExprs &);
};

class If : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;
  Expr *expr_3;

  If(const If &);
  If &operator=(const If &);
  If(Expr *p1, Expr *p2, Expr *p3);
  ~If();
  virtual void accept(Visitor *v);
  virtual If *clone() const;
  void swap(If &);
};

class Let : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Let(const Let &);
  Let &operator=(const Let &);
  Let(Expr *p1, Expr *p2);
  ~Let();
  virtual void accept(Visitor *v);
  virtual Let *clone() const;
  void swap(Let &);
};

class Abstraction : public Expr
{
public:
  Type *type_;
  Expr *expr_;

  Abstraction(const Abstraction &);
  Abstraction &operator=(const Abstraction &);
  Abstraction(Type *p1, Expr *p2);
  ~Abstraction();
  virtual void accept(Visitor *v);
  virtual Abstraction *clone() const;
  void swap(Abstraction &);
};

class Record : public Expr
{
public:
  ListBindingExpr *listbindingexpr_;

  Record(const Record &);
  Record &operator=(const Record &);
  Record(ListBindingExpr *p1);
  ~Record();
  virtual void accept(Visitor *v);
  virtual Record *clone() const;
  void swap(Record &);
};

class Application : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Application(const Application &);
  Application &operator=(const Application &);
  Application(Expr *p1, Expr *p2);
  ~Application();
  virtual void accept(Visitor *v);
  virtual Application *clone() const;
  void swap(Application &);
};

class Succ : public Expr
{
public:
  Expr *expr_;

  Succ(const Succ &);
  Succ &operator=(const Succ &);
  Succ(Expr *p1);
  ~Succ();
  virtual void accept(Visitor *v);
  virtual Succ *clone() const;
  void swap(Succ &);
};

class Dot : public Expr
{
public:
  Expr *expr_;
  Ident ident_;

  Dot(const Dot &);
  Dot &operator=(const Dot &);
  Dot(Expr *p1, Ident p2);
  ~Dot();
  virtual void accept(Visitor *v);
  virtual Dot *clone() const;
  void swap(Dot &);
};

class Pred : public Expr
{
public:
  Expr *expr_;

  Pred(const Pred &);
  Pred &operator=(const Pred &);
  Pred(Expr *p1);
  ~Pred();
  virtual void accept(Visitor *v);
  virtual Pred *clone() const;
  void swap(Pred &);
};

class IsZero : public Expr
{
public:
  Expr *expr_;

  IsZero(const IsZero &);
  IsZero &operator=(const IsZero &);
  IsZero(Expr *p1);
  ~IsZero();
  virtual void accept(Visitor *v);
  virtual IsZero *clone() const;
  void swap(IsZero &);
};

class ConstTrue : public Expr
{
public:

  ConstTrue(const ConstTrue &);
  ConstTrue &operator=(const ConstTrue &);
  ConstTrue();
  ~ConstTrue();
  virtual void accept(Visitor *v);
  virtual ConstTrue *clone() const;
  void swap(ConstTrue &);
};

class ConstFalse : public Expr
{
public:

  ConstFalse(const ConstFalse &);
  ConstFalse &operator=(const ConstFalse &);
  ConstFalse();
  ~ConstFalse();
  virtual void accept(Visitor *v);
  virtual ConstFalse *clone() const;
  void swap(ConstFalse &);
};

class ConstZero : public Expr
{
public:

  ConstZero(const ConstZero &);
  ConstZero &operator=(const ConstZero &);
  ConstZero();
  ~ConstZero();
  virtual void accept(Visitor *v);
  virtual ConstZero *clone() const;
  void swap(ConstZero &);
};

class FreeVar : public Expr
{
public:
  Ident ident_;

  FreeVar(const FreeVar &);
  FreeVar &operator=(const FreeVar &);
  FreeVar(Ident p1);
  ~FreeVar();
  virtual void accept(Visitor *v);
  virtual FreeVar *clone() const;
  void swap(FreeVar &);
};

class BoundVar : public Expr
{
public:
  Integer integer_;

  BoundVar(const BoundVar &);
  BoundVar &operator=(const BoundVar &);
  BoundVar(Integer p1);
  ~BoundVar();
  virtual void accept(Visitor *v);
  virtual BoundVar *clone() const;
  void swap(BoundVar &);
};

class Binding : public BindingExpr
{
public:
  Ident ident_;
  Expr *expr_;

  Binding(const Binding &);
  Binding &operator=(const Binding &);
  Binding(Ident p1, Expr *p2);
  ~Binding();
  virtual void accept(Visitor *v);
  virtual Binding *clone() const;
  void swap(Binding &);
};

class FunType : public Type
{
public:
  Type *type_1;
  Type *type_2;

  FunType(const FunType &);
  FunType &operator=(const FunType &);
  FunType(Type *p1, Type *p2);
  ~FunType();
  virtual void accept(Visitor *v);
  virtual FunType *clone() const;
  void swap(FunType &);
};

class RecordType : public Type
{
public:
  ListFieldTypeExpr *listfieldtypeexpr_;

  RecordType(const RecordType &);
  RecordType &operator=(const RecordType &);
  RecordType(ListFieldTypeExpr *p1);
  ~RecordType();
  virtual void accept(Visitor *v);
  virtual RecordType *clone() const;
  void swap(RecordType &);
};

class BoolType : public Type
{
public:

  BoolType(const BoolType &);
  BoolType &operator=(const BoolType &);
  BoolType();
  ~BoolType();
  virtual void accept(Visitor *v);
  virtual BoolType *clone() const;
  void swap(BoolType &);
};

class NatType : public Type
{
public:

  NatType(const NatType &);
  NatType &operator=(const NatType &);
  NatType();
  ~NatType();
  virtual void accept(Visitor *v);
  virtual NatType *clone() const;
  void swap(NatType &);
};

class FieldType : public FieldTypeExpr
{
public:
  Ident ident_;
  Type *type_;

  FieldType(const FieldType &);
  FieldType &operator=(const FieldType &);
  FieldType(Ident p1, Type *p2);
  ~FieldType();
  virtual void accept(Visitor *v);
  virtual FieldType *clone() const;
  void swap(FieldType &);
};

class TypingStmt : public Typing
{
public:
  Expr *expr_;
  Type *type_;

  TypingStmt(const TypingStmt &);
  TypingStmt &operator=(const TypingStmt &);
  TypingStmt(Expr *p1, Type *p2);
  ~TypingStmt();
  virtual void accept(Visitor *v);
  virtual TypingStmt *clone() const;
  void swap(TypingStmt &);
};



class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExpr *clone() const;
};

ListExpr* consListExpr(Expr* x, ListExpr* xs);

class ListBindingExpr : public Visitable, public std::vector<BindingExpr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListBindingExpr *clone() const;
};

ListBindingExpr* consListBindingExpr(BindingExpr* x, ListBindingExpr* xs);

class ListFieldTypeExpr : public Visitable, public std::vector<FieldTypeExpr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFieldTypeExpr *clone() const;
};

ListFieldTypeExpr* consListFieldTypeExpr(FieldTypeExpr* x, ListFieldTypeExpr* xs);




}
#endif
