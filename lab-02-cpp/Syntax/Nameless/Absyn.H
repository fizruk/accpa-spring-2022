/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef NAMELESS_ABSYN_HEADER
#define NAMELESS_ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.
namespace Nameless
{
/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class Expr;
class Type;
class Typing;
class ProgramExprs;
class ConstTrue;
class ConstFalse;
class If;
class ConstZero;
class Succ;
class Pred;
class IsZero;
class FreeVar;
class BoundVar;
class Abstraction;
class Application;
class FunType;
class BoolType;
class NatType;
class TypingStmt;
class ListExpr;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitTyping(Typing *p) = 0;
  virtual void visitProgramExprs(ProgramExprs *p) = 0;
  virtual void visitConstTrue(ConstTrue *p) = 0;
  virtual void visitConstFalse(ConstFalse *p) = 0;
  virtual void visitIf(If *p) = 0;
  virtual void visitConstZero(ConstZero *p) = 0;
  virtual void visitSucc(Succ *p) = 0;
  virtual void visitPred(Pred *p) = 0;
  virtual void visitIsZero(IsZero *p) = 0;
  virtual void visitFreeVar(FreeVar *p) = 0;
  virtual void visitBoundVar(BoundVar *p) = 0;
  virtual void visitAbstraction(Abstraction *p) = 0;
  virtual void visitApplication(Application *p) = 0;
  virtual void visitFunType(FunType *p) = 0;
  virtual void visitBoolType(BoolType *p) = 0;
  virtual void visitNatType(NatType *p) = 0;
  virtual void visitTypingStmt(TypingStmt *p) = 0;
  virtual void visitListExpr(ListExpr *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;
  int line_number, char_number;
};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;
  int line_number, char_number;
};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;
  int line_number, char_number;
};

class Typing : public Visitable
{
public:
  virtual Typing *clone() const = 0;
  int line_number, char_number;
};



class ProgramExprs : public Program
{
public:
  ListExpr *listexpr_;

  ProgramExprs(const ProgramExprs &);
  ProgramExprs &operator=(const ProgramExprs &);
  ProgramExprs(ListExpr *p1);
  ~ProgramExprs();
  virtual void accept(Visitor *v);
  virtual ProgramExprs *clone() const;
  void swap(ProgramExprs &);
};

class ConstTrue : public Expr
{
public:

  ConstTrue(const ConstTrue &);
  ConstTrue &operator=(const ConstTrue &);
  ConstTrue();
  ~ConstTrue();
  virtual void accept(Visitor *v);
  virtual ConstTrue *clone() const;
  void swap(ConstTrue &);
};

class ConstFalse : public Expr
{
public:

  ConstFalse(const ConstFalse &);
  ConstFalse &operator=(const ConstFalse &);
  ConstFalse();
  ~ConstFalse();
  virtual void accept(Visitor *v);
  virtual ConstFalse *clone() const;
  void swap(ConstFalse &);
};

class If : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;
  Expr *expr_3;

  If(const If &);
  If &operator=(const If &);
  If(Expr *p1, Expr *p2, Expr *p3);
  ~If();
  virtual void accept(Visitor *v);
  virtual If *clone() const;
  void swap(If &);
};

class ConstZero : public Expr
{
public:

  ConstZero(const ConstZero &);
  ConstZero &operator=(const ConstZero &);
  ConstZero();
  ~ConstZero();
  virtual void accept(Visitor *v);
  virtual ConstZero *clone() const;
  void swap(ConstZero &);
};

class Succ : public Expr
{
public:
  Expr *expr_;

  Succ(const Succ &);
  Succ &operator=(const Succ &);
  Succ(Expr *p1);
  ~Succ();
  virtual void accept(Visitor *v);
  virtual Succ *clone() const;
  void swap(Succ &);
};

class Pred : public Expr
{
public:
  Expr *expr_;

  Pred(const Pred &);
  Pred &operator=(const Pred &);
  Pred(Expr *p1);
  ~Pred();
  virtual void accept(Visitor *v);
  virtual Pred *clone() const;
  void swap(Pred &);
};

class IsZero : public Expr
{
public:
  Expr *expr_;

  IsZero(const IsZero &);
  IsZero &operator=(const IsZero &);
  IsZero(Expr *p1);
  ~IsZero();
  virtual void accept(Visitor *v);
  virtual IsZero *clone() const;
  void swap(IsZero &);
};

class FreeVar : public Expr
{
public:
  Ident ident_;

  FreeVar(const FreeVar &);
  FreeVar &operator=(const FreeVar &);
  FreeVar(Ident p1);
  ~FreeVar();
  virtual void accept(Visitor *v);
  virtual FreeVar *clone() const;
  void swap(FreeVar &);
};

class BoundVar : public Expr
{
public:
  Integer integer_;

  BoundVar(const BoundVar &);
  BoundVar &operator=(const BoundVar &);
  BoundVar(Integer p1);
  ~BoundVar();
  virtual void accept(Visitor *v);
  virtual BoundVar *clone() const;
  void swap(BoundVar &);
};

class Abstraction : public Expr
{
public:
  Type *type_;
  Expr *expr_;

  Abstraction(const Abstraction &);
  Abstraction &operator=(const Abstraction &);
  Abstraction(Type *p1, Expr *p2);
  ~Abstraction();
  virtual void accept(Visitor *v);
  virtual Abstraction *clone() const;
  void swap(Abstraction &);
};

class Application : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Application(const Application &);
  Application &operator=(const Application &);
  Application(Expr *p1, Expr *p2);
  ~Application();
  virtual void accept(Visitor *v);
  virtual Application *clone() const;
  void swap(Application &);
};

class FunType : public Type
{
public:
  Type *type_1;
  Type *type_2;

  FunType(const FunType &);
  FunType &operator=(const FunType &);
  FunType(Type *p1, Type *p2);
  ~FunType();
  virtual void accept(Visitor *v);
  virtual FunType *clone() const;
  void swap(FunType &);
};

class BoolType : public Type
{
public:

  BoolType(const BoolType &);
  BoolType &operator=(const BoolType &);
  BoolType();
  ~BoolType();
  virtual void accept(Visitor *v);
  virtual BoolType *clone() const;
  void swap(BoolType &);
};

class NatType : public Type
{
public:

  NatType(const NatType &);
  NatType &operator=(const NatType &);
  NatType();
  ~NatType();
  virtual void accept(Visitor *v);
  virtual NatType *clone() const;
  void swap(NatType &);
};

class TypingStmt : public Typing
{
public:
  Expr *expr_;
  Type *type_;

  TypingStmt(const TypingStmt &);
  TypingStmt &operator=(const TypingStmt &);
  TypingStmt(Expr *p1, Type *p2);
  ~TypingStmt();
  virtual void accept(Visitor *v);
  virtual TypingStmt *clone() const;
  void swap(TypingStmt &);
};



class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExpr *clone() const;
};

ListExpr* consListExpr(Expr* x, ListExpr* xs);




}
#endif
