/* File generated by the BNF Converter (bnfc 2.9.4). */

/*** Visitor Design Pattern Skeleton. ***/
/* This implements the common visitor design pattern.
   Note that this method uses Visitor-traversal of lists, so
   List->accept() does NOT traverse the list. This allows different
   algorithms to use context information differently. */

#include "Skeleton.H"


namespace Normal
{
void Skeleton::visitProgram(Program *t) {} //abstract class
void Skeleton::visitExpr(Expr *t) {} //abstract class
void Skeleton::visitType(Type *t) {} //abstract class
void Skeleton::visitTyping(Typing *t) {} //abstract class

void Skeleton::visitProgramExprs(ProgramExprs *program_exprs)
{
  /* Code For ProgramExprs Goes Here */

  if (program_exprs->listexpr_) program_exprs->listexpr_->accept(this);

}

void Skeleton::visitIf(If *if_)
{
  /* Code For If Goes Here */

  if (if_->expr_1) if_->expr_1->accept(this);
  if (if_->expr_2) if_->expr_2->accept(this);
  if (if_->expr_3) if_->expr_3->accept(this);

}

void Skeleton::visitAbstraction(Abstraction *abstraction)
{
  /* Code For Abstraction Goes Here */

  visitIdent(abstraction->ident_);
  if (abstraction->type_) abstraction->type_->accept(this);
  if (abstraction->expr_) abstraction->expr_->accept(this);

}

void Skeleton::visitApplication(Application *application)
{
  /* Code For Application Goes Here */

  if (application->expr_1) application->expr_1->accept(this);
  if (application->expr_2) application->expr_2->accept(this);

}

void Skeleton::visitSucc(Succ *succ)
{
  /* Code For Succ Goes Here */

  if (succ->expr_) succ->expr_->accept(this);

}

void Skeleton::visitPred(Pred *pred)
{
  /* Code For Pred Goes Here */

  if (pred->expr_) pred->expr_->accept(this);

}

void Skeleton::visitIsZero(IsZero *is_zero)
{
  /* Code For IsZero Goes Here */

  if (is_zero->expr_) is_zero->expr_->accept(this);

}

void Skeleton::visitConstTrue(ConstTrue *const_true)
{
  /* Code For ConstTrue Goes Here */


}

void Skeleton::visitConstFalse(ConstFalse *const_false)
{
  /* Code For ConstFalse Goes Here */


}

void Skeleton::visitConstZero(ConstZero *const_zero)
{
  /* Code For ConstZero Goes Here */


}

void Skeleton::visitVar(Var *var)
{
  /* Code For Var Goes Here */

  visitIdent(var->ident_);

}

void Skeleton::visitFunType(FunType *fun_type)
{
  /* Code For FunType Goes Here */

  if (fun_type->type_1) fun_type->type_1->accept(this);
  if (fun_type->type_2) fun_type->type_2->accept(this);

}

void Skeleton::visitBoolType(BoolType *bool_type)
{
  /* Code For BoolType Goes Here */


}

void Skeleton::visitNatType(NatType *nat_type)
{
  /* Code For NatType Goes Here */


}

void Skeleton::visitTypingStmt(TypingStmt *typing_stmt)
{
  /* Code For TypingStmt Goes Here */

  if (typing_stmt->expr_) typing_stmt->expr_->accept(this);
  if (typing_stmt->type_) typing_stmt->type_->accept(this);

}


void Skeleton::visitListExpr(ListExpr *list_expr)
{
  for (ListExpr::iterator i = list_expr->begin() ; i != list_expr->end() ; ++i)
  {
    (*i)->accept(this);
  }
}


void Skeleton::visitInteger(Integer x)
{
  /* Code for Integer Goes Here */
}

void Skeleton::visitChar(Char x)
{
  /* Code for Char Goes Here */
}

void Skeleton::visitDouble(Double x)
{
  /* Code for Double Goes Here */
}

void Skeleton::visitString(String x)
{
  /* Code for String Goes Here */
}

void Skeleton::visitIdent(Ident x)
{
  /* Code for Ident Goes Here */
}


}
