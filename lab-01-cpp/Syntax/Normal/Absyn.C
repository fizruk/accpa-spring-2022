/* File generated by the BNF Converter (bnfc 2.9.4). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"
namespace Normal
{
/********************   ProgramExprs    ********************/
ProgramExprs::ProgramExprs(ListExpr *p1)
{
  listexpr_ = p1;

}

ProgramExprs::ProgramExprs(const ProgramExprs & other)
{
  listexpr_ = other.listexpr_->clone();

}

ProgramExprs &ProgramExprs::operator=(const ProgramExprs & other)
{
  ProgramExprs tmp(other);
  swap(tmp);
  return *this;
}

void ProgramExprs::swap(ProgramExprs & other)
{
  std::swap(listexpr_, other.listexpr_);

}

ProgramExprs::~ProgramExprs()
{
  delete(listexpr_);

}

void ProgramExprs::accept(Visitor *v)
{
  v->visitProgramExprs(this);
}

ProgramExprs *ProgramExprs::clone() const
{
  return new ProgramExprs(*this);
}



/********************   ConstTrue    ********************/
ConstTrue::ConstTrue()
{

}

ConstTrue::ConstTrue(const ConstTrue & other)
{

}

ConstTrue &ConstTrue::operator=(const ConstTrue & other)
{
  ConstTrue tmp(other);
  swap(tmp);
  return *this;
}

void ConstTrue::swap(ConstTrue & other)
{

}

ConstTrue::~ConstTrue()
{

}

void ConstTrue::accept(Visitor *v)
{
  v->visitConstTrue(this);
}

ConstTrue *ConstTrue::clone() const
{
  return new ConstTrue(*this);
}



/********************   ConstFalse    ********************/
ConstFalse::ConstFalse()
{

}

ConstFalse::ConstFalse(const ConstFalse & other)
{

}

ConstFalse &ConstFalse::operator=(const ConstFalse & other)
{
  ConstFalse tmp(other);
  swap(tmp);
  return *this;
}

void ConstFalse::swap(ConstFalse & other)
{

}

ConstFalse::~ConstFalse()
{

}

void ConstFalse::accept(Visitor *v)
{
  v->visitConstFalse(this);
}

ConstFalse *ConstFalse::clone() const
{
  return new ConstFalse(*this);
}



/********************   If    ********************/
If::If(Expr *p1, Expr *p2, Expr *p3)
{
  expr_1 = p1;
  expr_2 = p2;
  expr_3 = p3;

}

If::If(const If & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();
  expr_3 = other.expr_3->clone();

}

If &If::operator=(const If & other)
{
  If tmp(other);
  swap(tmp);
  return *this;
}

void If::swap(If & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);
  std::swap(expr_3, other.expr_3);

}

If::~If()
{
  delete(expr_1);
  delete(expr_2);
  delete(expr_3);

}

void If::accept(Visitor *v)
{
  v->visitIf(this);
}

If *If::clone() const
{
  return new If(*this);
}



/********************   ConstZero    ********************/
ConstZero::ConstZero()
{

}

ConstZero::ConstZero(const ConstZero & other)
{

}

ConstZero &ConstZero::operator=(const ConstZero & other)
{
  ConstZero tmp(other);
  swap(tmp);
  return *this;
}

void ConstZero::swap(ConstZero & other)
{

}

ConstZero::~ConstZero()
{

}

void ConstZero::accept(Visitor *v)
{
  v->visitConstZero(this);
}

ConstZero *ConstZero::clone() const
{
  return new ConstZero(*this);
}



/********************   Succ    ********************/
Succ::Succ(Expr *p1)
{
  expr_ = p1;

}

Succ::Succ(const Succ & other)
{
  expr_ = other.expr_->clone();

}

Succ &Succ::operator=(const Succ & other)
{
  Succ tmp(other);
  swap(tmp);
  return *this;
}

void Succ::swap(Succ & other)
{
  std::swap(expr_, other.expr_);

}

Succ::~Succ()
{
  delete(expr_);

}

void Succ::accept(Visitor *v)
{
  v->visitSucc(this);
}

Succ *Succ::clone() const
{
  return new Succ(*this);
}



/********************   Pred    ********************/
Pred::Pred(Expr *p1)
{
  expr_ = p1;

}

Pred::Pred(const Pred & other)
{
  expr_ = other.expr_->clone();

}

Pred &Pred::operator=(const Pred & other)
{
  Pred tmp(other);
  swap(tmp);
  return *this;
}

void Pred::swap(Pred & other)
{
  std::swap(expr_, other.expr_);

}

Pred::~Pred()
{
  delete(expr_);

}

void Pred::accept(Visitor *v)
{
  v->visitPred(this);
}

Pred *Pred::clone() const
{
  return new Pred(*this);
}



/********************   IsZero    ********************/
IsZero::IsZero(Expr *p1)
{
  expr_ = p1;

}

IsZero::IsZero(const IsZero & other)
{
  expr_ = other.expr_->clone();

}

IsZero &IsZero::operator=(const IsZero & other)
{
  IsZero tmp(other);
  swap(tmp);
  return *this;
}

void IsZero::swap(IsZero & other)
{
  std::swap(expr_, other.expr_);

}

IsZero::~IsZero()
{
  delete(expr_);

}

void IsZero::accept(Visitor *v)
{
  v->visitIsZero(this);
}

IsZero *IsZero::clone() const
{
  return new IsZero(*this);
}



/********************   Var    ********************/
Var::Var(Ident p1)
{
  ident_ = p1;

}

Var::Var(const Var & other)
{
  ident_ = other.ident_;

}

Var &Var::operator=(const Var & other)
{
  Var tmp(other);
  swap(tmp);
  return *this;
}

void Var::swap(Var & other)
{
  std::swap(ident_, other.ident_);

}

Var::~Var()
{

}

void Var::accept(Visitor *v)
{
  v->visitVar(this);
}

Var *Var::clone() const
{
  return new Var(*this);
}



/********************   Abstraction    ********************/
Abstraction::Abstraction(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

Abstraction::Abstraction(const Abstraction & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

Abstraction &Abstraction::operator=(const Abstraction & other)
{
  Abstraction tmp(other);
  swap(tmp);
  return *this;
}

void Abstraction::swap(Abstraction & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

Abstraction::~Abstraction()
{
  delete(expr_);

}

void Abstraction::accept(Visitor *v)
{
  v->visitAbstraction(this);
}

Abstraction *Abstraction::clone() const
{
  return new Abstraction(*this);
}



/********************   Application    ********************/
Application::Application(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Application::Application(const Application & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Application &Application::operator=(const Application & other)
{
  Application tmp(other);
  swap(tmp);
  return *this;
}

void Application::swap(Application & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Application::~Application()
{
  delete(expr_1);
  delete(expr_2);

}

void Application::accept(Visitor *v)
{
  v->visitApplication(this);
}

Application *Application::clone() const
{
  return new Application(*this);
}




/********************   ListExpr    ********************/

void ListExpr::accept(Visitor *v)
{
  v->visitListExpr(this);
}

ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}

ListExpr* consListExpr(Expr* x, ListExpr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}




}
