/* File generated by the BNF Converter (bnfc 2.9.4). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"
namespace Nameless
{
/********************   ConstTrue    ********************/
ConstTrue::ConstTrue()
{

}

ConstTrue::ConstTrue(const ConstTrue & other)
{

}

ConstTrue &ConstTrue::operator=(const ConstTrue & other)
{
  ConstTrue tmp(other);
  swap(tmp);
  return *this;
}

void ConstTrue::swap(ConstTrue & other)
{

}

ConstTrue::~ConstTrue()
{

}

void ConstTrue::accept(Visitor *v)
{
  v->visitConstTrue(this);
}

ConstTrue *ConstTrue::clone() const
{
  return new ConstTrue(*this);
}



/********************   ConstFalse    ********************/
ConstFalse::ConstFalse()
{

}

ConstFalse::ConstFalse(const ConstFalse & other)
{

}

ConstFalse &ConstFalse::operator=(const ConstFalse & other)
{
  ConstFalse tmp(other);
  swap(tmp);
  return *this;
}

void ConstFalse::swap(ConstFalse & other)
{

}

ConstFalse::~ConstFalse()
{

}

void ConstFalse::accept(Visitor *v)
{
  v->visitConstFalse(this);
}

ConstFalse *ConstFalse::clone() const
{
  return new ConstFalse(*this);
}



/********************   If    ********************/
If::If(Expr *p1, Expr *p2, Expr *p3)
{
  expr_1 = p1;
  expr_2 = p2;
  expr_3 = p3;

}

If::If(const If & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();
  expr_3 = other.expr_3->clone();

}

If &If::operator=(const If & other)
{
  If tmp(other);
  swap(tmp);
  return *this;
}

void If::swap(If & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);
  std::swap(expr_3, other.expr_3);

}

If::~If()
{
  delete(expr_1);
  delete(expr_2);
  delete(expr_3);

}

void If::accept(Visitor *v)
{
  v->visitIf(this);
}

If *If::clone() const
{
  return new If(*this);
}



/********************   ConstZero    ********************/
ConstZero::ConstZero()
{

}

ConstZero::ConstZero(const ConstZero & other)
{

}

ConstZero &ConstZero::operator=(const ConstZero & other)
{
  ConstZero tmp(other);
  swap(tmp);
  return *this;
}

void ConstZero::swap(ConstZero & other)
{

}

ConstZero::~ConstZero()
{

}

void ConstZero::accept(Visitor *v)
{
  v->visitConstZero(this);
}

ConstZero *ConstZero::clone() const
{
  return new ConstZero(*this);
}



/********************   Succ    ********************/
Succ::Succ(Expr *p1)
{
  expr_ = p1;

}

Succ::Succ(const Succ & other)
{
  expr_ = other.expr_->clone();

}

Succ &Succ::operator=(const Succ & other)
{
  Succ tmp(other);
  swap(tmp);
  return *this;
}

void Succ::swap(Succ & other)
{
  std::swap(expr_, other.expr_);

}

Succ::~Succ()
{
  delete(expr_);

}

void Succ::accept(Visitor *v)
{
  v->visitSucc(this);
}

Succ *Succ::clone() const
{
  return new Succ(*this);
}



/********************   Pred    ********************/
Pred::Pred(Expr *p1)
{
  expr_ = p1;

}

Pred::Pred(const Pred & other)
{
  expr_ = other.expr_->clone();

}

Pred &Pred::operator=(const Pred & other)
{
  Pred tmp(other);
  swap(tmp);
  return *this;
}

void Pred::swap(Pred & other)
{
  std::swap(expr_, other.expr_);

}

Pred::~Pred()
{
  delete(expr_);

}

void Pred::accept(Visitor *v)
{
  v->visitPred(this);
}

Pred *Pred::clone() const
{
  return new Pred(*this);
}



/********************   IsZero    ********************/
IsZero::IsZero(Expr *p1)
{
  expr_ = p1;

}

IsZero::IsZero(const IsZero & other)
{
  expr_ = other.expr_->clone();

}

IsZero &IsZero::operator=(const IsZero & other)
{
  IsZero tmp(other);
  swap(tmp);
  return *this;
}

void IsZero::swap(IsZero & other)
{
  std::swap(expr_, other.expr_);

}

IsZero::~IsZero()
{
  delete(expr_);

}

void IsZero::accept(Visitor *v)
{
  v->visitIsZero(this);
}

IsZero *IsZero::clone() const
{
  return new IsZero(*this);
}



/********************   FreeVar    ********************/
FreeVar::FreeVar(Ident p1)
{
  ident_ = p1;

}

FreeVar::FreeVar(const FreeVar & other)
{
  ident_ = other.ident_;

}

FreeVar &FreeVar::operator=(const FreeVar & other)
{
  FreeVar tmp(other);
  swap(tmp);
  return *this;
}

void FreeVar::swap(FreeVar & other)
{
  std::swap(ident_, other.ident_);

}

FreeVar::~FreeVar()
{

}

void FreeVar::accept(Visitor *v)
{
  v->visitFreeVar(this);
}

FreeVar *FreeVar::clone() const
{
  return new FreeVar(*this);
}



/********************   BoundVar    ********************/
BoundVar::BoundVar(Integer p1)
{
  integer_ = p1;

}

BoundVar::BoundVar(const BoundVar & other)
{
  integer_ = other.integer_;

}

BoundVar &BoundVar::operator=(const BoundVar & other)
{
  BoundVar tmp(other);
  swap(tmp);
  return *this;
}

void BoundVar::swap(BoundVar & other)
{
  std::swap(integer_, other.integer_);

}

BoundVar::~BoundVar()
{

}

void BoundVar::accept(Visitor *v)
{
  v->visitBoundVar(this);
}

BoundVar *BoundVar::clone() const
{
  return new BoundVar(*this);
}



/********************   Abstraction    ********************/
Abstraction::Abstraction(Expr *p1)
{
  expr_ = p1;

}

Abstraction::Abstraction(const Abstraction & other)
{
  expr_ = other.expr_->clone();

}

Abstraction &Abstraction::operator=(const Abstraction & other)
{
  Abstraction tmp(other);
  swap(tmp);
  return *this;
}

void Abstraction::swap(Abstraction & other)
{
  std::swap(expr_, other.expr_);

}

Abstraction::~Abstraction()
{
  delete(expr_);

}

void Abstraction::accept(Visitor *v)
{
  v->visitAbstraction(this);
}

Abstraction *Abstraction::clone() const
{
  return new Abstraction(*this);
}



/********************   Application    ********************/
Application::Application(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Application::Application(const Application & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Application &Application::operator=(const Application & other)
{
  Application tmp(other);
  swap(tmp);
  return *this;
}

void Application::swap(Application & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Application::~Application()
{
  delete(expr_1);
  delete(expr_2);

}

void Application::accept(Visitor *v)
{
  v->visitApplication(this);
}

Application *Application::clone() const
{
  return new Application(*this);
}






}
